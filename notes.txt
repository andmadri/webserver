//TCP/IP follows a standard format called Network Byte Order
//which is big-endian. The problem is that if a little-endian computer sends
//data without conversion, the bytes may be interpreted incorrectly, which is big-endian

//bind function
    //htonl() from long to network bites
    //htons from short intger to a network representation
//address.sin_addr.s_addr = htonl(INADDR_ANY); 
//address.sin_port = htons(PORT); 

// if (bind(sockfd, reinterpret_cast<struct sockaddr *>(&server_addr), sizeof(server_addr)) < 0) {
//      throw std::exception();
//  }
//tradinioally this operation is called assigning a name to the socket
//We want to assign an IP address and a port to the socket
//The sockaddr struct depends on Adress Family, the purpose of the struct is to
//cast the structure pointer passed in addr in order to avoid compiler warnings


//listen marks the socket referred to by sockfd as a passive socket, that is, a socket that will be
//used to accept incomung connection requests.
//The backlog argument defines the maximum length to which the queue of pending
//connection for sockfd may grow.
//accept() grabs the first pending connectino waiting in listen() and creates a socket
//The original socket that was set up for listening is used only for accepting connections, not for exchanging data
//accept() would only accept a connection until it is present in the queue.

//if (listen(sockfd, BACKLOG) < 0) {
//  throw std::exception();
//}
/*
while(1) {
    printf("\n----Waiting for new connection----\n\n")
    int new_socket = accept(sockfd, std::reinterpret_cast<struct sockaddr *>(&server_addr), sizeof(server_addr));
    if (new_socket < 0) {
        throw std::exception();
    }
    //communication from the client to server just happened thanks to the accpet function
    char buffer[3000] = {0};
    int valread = read(new_socket, buffer, 30000)
    printf("%s\n", buffer);
    write(new_socket, "something", strlen("something"));
    printf("----Message sent to Client----\n");
    close(new_socket);
}
*/